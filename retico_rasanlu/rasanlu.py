"""A module for Natural Language Understanding provided by rasa_nlu"""

# retico
from retico_core import abstract
from retico_core.text import SpeechRecognitionIU
from retico_core.dialogue import DialogueActIU

# rasa
import sys
import os
import asyncio
from functools import wraps, partial
# sys.path.append(os.environ['RASA'])
# from rasa.nlu.model import IncrementalInterpreter as Interpreter
from rasa.core.agent import Agent, load_agent

class RasaNLUModule(abstract.AbstractModule):
    """A standard rasa NLU module.

    Attributes:
        model_dir (str): The path to the directory of the NLU model generated by
            rasa_nlu.train.
        config_file (str): The path to the json file containing the rasa nlu
            configuration.
    """

    @staticmethod
    def name():
        return "Rasa NLU Module"

    @staticmethod
    def description():
        return "A Module providing Natural Language Understanding by rasa_nlu"

    @staticmethod
    def input_ius():
        return [SpeechRecognitionIU]

    @staticmethod
    def output_iu():
        return DialogueActIU

    def __init__(self, model_dir, incremental=True, preprocessor = None, **kwargs):
        """Initializes the RasaNLUModule.

        Args:
            model_dir (str): The path to the directory of the NLU model
                generated by rasa_nlu.train.
        """
        super().__init__(**kwargs)
        self.model_dir = model_dir
        self.interpreter = None
        self.incremental = incremental
        self.lb_hypotheses = []
        self.cache = None
        self.started_prediction = False
        self.prefix = []

        if ".tar.gz" in model_dir[-7:]:
            self.interpreter =  Agent.load(model_path=model_dir) 
        else:
            self.load_latest_model()

        self.imported_preprocessor = preprocessor

    def load_latest_model(self):
        files = os.listdir(self.model_dir) 
        paths = [os.path.join(self.model_dir, basename) for basename in files] 
        latest_file = max(paths, key=os.path.getctime) 
        print("NLU loading latest file", latest_file)
        self.interpreter =  Agent.load(model_path=latest_file)   
    
    async def new_utterance(self):
        print("New Utterance called")
        self.prefix = []
        #super().new_utterance()

    async def process_result(self, result, input_iu):
        #print("RESULT: {}".format(result))
        payload = {}
        for entity in result.get("entities"):
            if entity["entity"] in payload:
                payload[entity["entity"]].append(entity["value"])
            else:
                payload[entity["entity"]] = [entity["value"]]
            # concepts['{}_confidence'.format(entity["entity"])] = entity['confidence']
        act = result["intent"]["name"]
        payload['intent'] = act                                     #should this be added??????
        payload['text'] = result["text"]
        # confidence = result["intent"]["confidence"]
        # print('nlu', act, concepts, confidence)
        output_iu = self.create_iu(input_iu)
        output_iu.payload = payload
        piu = output_iu.previous_iu
        payload['commit'] = input_iu.committed
        if input_iu.committed:
            output_iu.committed = True
            self.started_prediction = False
        else:
            self.started_prediction = True
        update_iu = abstract.UpdateMessage()
        update_iu = abstract.UpdateMessage.from_iu(output_iu, abstract.UpdateType.ADD)            
        return update_iu

    def process_update(self, update_message):
        print("NLU getting update")
        result = ""
        for iu,um in update_message:
            print(um)
            if um == abstract.UpdateType.ADD:
                self.process_iu(iu)
            elif um == abstract.UpdateType.REVOKE:
                self.process_revoke(iu)

    def preproccessor(self, text):
        "Just make the final return value a full sentance for the default preprocessor"
        if self.imported_preprocessor:
            return self.imported_preprocessor(text)
        #define your own preproccessor
        return text

    def process_iu(self, input_iu):
        if self.incremental:

            tokens=self.preproccessor(input_iu.get_text()).split()

            if len(tokens) == 0 and input_iu.committed:
                tokens = [("", "commit")]
            elif input_iu.committed:
                tokens = [(word,"add") for word in tokens]
                tokens.append(("","commit"))
            elif len(tokens) == 0 and input_iu.committed == False:
                return
            else:
                tokens = [(word,"add") for word in tokens]

            for text_iu in tokens:
                
                async def async_interpret(text_iu):
                    result = await self.interpreter.parse_incremental(text_iu)
                    if result is not None:
                        p_result = await self.process_result(result, input_iu)
                        self.append(p_result)
                    if text_iu[1] == "commit":
                        await self.new_utterance()

                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                coroutine = async_interpret(text_iu)
                loop.run_until_complete(coroutine)
                
        else:
            self.prefix.append(input_iu.get_text())
            text = ' '.join(self.prefix)
            # we need to do some shananigans to make the async RASA interpreter work in a synchronous function
            async def async_interpret(text):
                result = await self.interpreter.parse_message(message_data=text)
                if result is not None:
                    p_result = await self.process_result(result, input_iu)
                    self.append(p_result)
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            coroutine = async_interpret(text)
            loop.run_until_complete(coroutine)
        

    def process_revoke(self, revoked_iu):
        
        result =  None
        if self.incremental:

            tokens = tokens=self.preproccessor(revoked_iu.get_text()).split()
            tokens.reverse()
            print(tokens)

            async def async_interpret(revoked_iu,tokens):
                for word in tokens:
                    text_iu = (word, "revoke")
                    # print('nlu revoke({})'.format(word))
                    result = await self.interpreter.parse_incremental(text_iu)
                
                #should this be indented???
                if result is not None:
                    result = await self.process_result(result, revoked_iu)
            
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            coroutine = async_interpret(revoked_iu,tokens)
            loop.run_until_complete(coroutine)
               
        else:
            if len(self.prefix) > 0:
                self.prefix.pop()
        
        try:  #no iu_stack error??? This was happening before I made any changes
            if len(self._iu_stack) > 0:
                last_output_iu = self._iu_stack.pop()
                self.revoke(last_output_iu)
        except:
            pass
            
        
        return result

    def setup(self):
        pass


